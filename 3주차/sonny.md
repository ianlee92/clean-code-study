# 6장. 객체와 자료 구조

## 자료 추상화

### 진정한 의미의 클래스 (p.119)

```md
변수 사이에 함수라는 계층을 넣는다고 구현이 저절로 감춰지지는 않는다.
구현을 감추려면 추상화가 필요하다! 그저 (형식 논리에 치우쳐) 조회 함수와 설정 함수로 변수를 다룬다고 클래스가 되지는 않는다.
그보다는 추상 인터페이스를 제공해 사용자가 구현을 모른 채 자료의 핵심을 조작할 수 있어야 진정한 의미의 클래스다.
```

### 절차적인 코드와 객체 지향 코드의 차이점 (p.122)

|절차적인 코드|객체 지향 코드|
|------|---|
|기존 자료구조 변경 하지 않으면서 새 함수를 추가하기 쉬움|기존 함수를 변경하지 않으면서 새 클래스를 추가하기 쉬움|
|새로운 자료 구조를 추가하기 어려움, 자료 구조 추가 시, 모든 함수를 고쳐야 함|새로운 함수를 추가하기 어려움, 모든 클래스를 고쳐야 함|
|새로운 자료 타입이 아니라 새로운 함수가 필요한 경우 적합|새로운 함수가 아닌 새로운 자료 타입이 필요한 경우에 적합|

## 디미터 법칙 (p.123)

- 모듈은 자신이 조작하는 객체의 속사정을 몰라야 한다는 법칙.
- 객체는 자료를 숨기고 함수를 공개한다.
  -> 객체는 조회 함수로 내부 구조를 공개하면 안된다

### 잡종 구조 (p.124)

```md
자료 구조는 무조건 함수 없이 공개 변수만 포함하고 객체는 비공개 변수와 공개 함수를 포함한다면, 문제는 훨씬 간단하다.
때때로 절반은 객체, 절반은 자료 구조인 잡종구조가 나온다. 잡종 구조는 새로운 함수는 물론이고 새로운 자료 구조도 추가하기 어렵다.
양쪽 세상에서 단점만 모아놓은 구조다.
```

### 구조체 감추기 (p.125)

- 객체라면, 내부 구조를 감춰야 한다.
  - 객체라면 **뭔가를 하라고** 말해야지 속을 드러내라고 말하면 안된다.
- 구조체를 감추는 방법
  - 어떤 것을 얻으려는 이유에 대해 확인해보기
    (Ex. 절대 경로를 얻어 임시 파일을 생성해야 하기 때문에 절대 경로를 얻어야 한다.)
  - 얻으려 했던 이유를 목적으로 하는 행동을 시키는 함수를 만들기

## 자료 전달 객체 (p.126)

자료 구조체의 전형적인 형태는 공개 변수만 있고 함수가 없는 클래스

### 객체와 자료 구조 (p.127)

|객체|자료 구조|
|------|---|
|동작 공개, 자료 숨김|자료 노출|
|기존 동작을 변경하지 않으면서 새 객체 타입을 추가하기 쉬움|기존 객체에 새 동작을 추가|기존 자료 구조에 새 동작을 추가하기 쉬움|
|기존 객체에 새 동작을 추가하기 어려움|기존 함수에 새 자료 구조를 추가하기 어려움|

# 10장. 클래스

## 클래스 체계

### 클래스 관련 표준 자바 관례 (p. 172)

- 변수 목록
  - 정적 공개 상수
  - 정적 비공개 변수
  - 비공개 인스턴스 변수
- 공개 함수
- 비공개 함수
  - 자신을 호출하는 공개 함수 직후에 위치

추상화 단계가 순차적으로 내려가 프로그램은 신문 기사처럼 읽힘

## 클래스는 작아야 한다 (p.172)

클래스를 설계할 때도, 함수와 마찬가지로, '작게'가 기본 규칙이라는 의미

### 클래스의 책임 (p.175)

- 함수는 물리적인 행 수로 크기를 측정하지만 클래스는 맡은 책임을 센다.
- 메서드 수가 작음에도 불구하고 책임이 너무 많으면 쪼개기
- 클래스 이름은 해당 클래스 책임을 기술해야 한다.
  - 작명은 클래스 크기를 줄이는 첫 번째 관문

### 단일 책임 원칙 (p. 176)

- 클래스나 모듈을 변경할 이유가 하나, 단 하나뿐이어야 한다는 원칙
  - 클래스는 책임, 즉 변경할 이유가 하나여야 한다.

### 큰 클래스와 작은 클래스 (p. 176 ~ p.177)

```md
많은 개발자는 자잘한 단일 책임 클래스가 많아지면 큰 그림을 이해하기 어려워진다고 우려한다.
큰 그림을 이해하려면 이 클래스 저 클래스를 수없이 넘나들어야 한다고 걱정한다.
하지만 작은 클래스가 많은 시스템이든 큰 클래스가 몇 개뿐인 시스템이든 돌아가는 부품은 그 수가 비슷하다.

"도구 상자를 어떻게 관리하고 싶은가? 작은 서랍을 많이 두고 기능과 이름이 명확한 컴포넌트를 나눠 넣고 싶은가?
아니면 큰 서랍 몇 개를 두고 모두를 던져 넣고 싶은가?"

큰 클래스 몇개가 아니라 작은 클래스 여럿으로 이뤄진 시스템이 더 바람직하다.
작은 클래스는 각자 맡은 책임이 하나며, 변경할 이유가 하나며,
다른 작은 클래스와 협력해 시스템에 필요한 동작을 수행한다.
```

### 응집도 (p.177)

```md
클래스는 인스턴스 변수 수가 작아야 한다. 각 클래스 메서드는 클래스 인스턴스 변수를 하나 이상 사용해야 한다.
일반적으로 메서드가 변수를 더 많이 사용할수록 메서드와 클래스는 응집도가 더 높다.
모든 인스턴스 변수를 메서드마다 사용하는 클래스는 응집도가 가장 높다.

때떄로 몇몇 메서드만이 사용하는 인스턴스 변수가 아주 많아진다. 새로운 클래스로 쪼개야 한다는 신호다.
응집도가 높아지도록 변수와 메서드를 적절히 분리해 새로운 클래스 두세 개로 쪼개준다.
```

### 응집도를 유지하면 작은 클래스 여럿이 나온다 (p.178)

Q. 큰 함수 일부를 작은 함수 하나로 빼내고 싶은데, 빼내려는 코드가 큰 함수에 정의된 변수 넷을 사용한다.
그렇다면 변수 네 개를 새 함수에 인수로 넘겨야 옳을까?

A. 전혀 아니다! 만약 네 변수를 클래스 인스턴스 변수로 승격한다면 새 함수는 인수가 **필요없다.**
그만큼 함수를 쪼개기 **쉬워진다.**
- 몇몇 함수만 사용하는 인스턴스가 점점 더 늘어나기 때문에 이렇게 하면 클래스가 응집력을 잃는다.
  -> 몇몇 함수가 몇몇 변수만 사용한다면 독자적인 클래스로 분리해도 된다. 클래스가 응집력을 잃는다면 쪼개라!
  -> 프로그램에 점점 더 체계가 잡히고 구조가 투명해진다.