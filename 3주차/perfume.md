## 6. 객체와 자료 구조

객체 지향 프로그래밍을 공부하다보면 "추상화", "캡슐화" 같은 단어를 반드시 접하게 됩니다. 이 책의 6장에서도 이와 관련된 개념들을 볼 수 있는데요. (사실 개인적으로 6장이 어려웠어서 제가 제대로 이해한지 모르겠습니다!)

먼저 6장의 제목이 된 객체와 자료 구조 이 둘은 사실상 정반대의 개념입니다.

> **객체:** 추상화를 통해 자료를 숨긴 채 자료를 다루는 **함수만 공개**합니다.
> **자료 구조:** **자료를 그대로 공개**하며 별다른 함수는 제공하지 않습니다.

이 둘의 차이에서 객체지향 프로그래밍과 절차형 프로그래밍이 양분됩니다. 자료구조를 사용하는 절차적인 코드는 기존 자료 구조를 변경하지 않으면서 새 함수를 추가하기 쉽습니다. 하지만 새로운 자료 구조를 추가하긴 어렵습니다. 반면 객체 지향 코드는 기존 함수를 변경하지 않으면서 새 클래스를 추가하긴 쉽지만, 새로운 함수를 추가하려면 모든 클래스를 고쳐야 합니다.

그렇기 때문에 둘은 상황에 따라 적합한 것을 선택하여 사용하는 것이 좋습니다.

### 디미터 법칙

디미터 법칙이란 모듈이 자신이 조작하는 객체의 속사정을 몰라야 한다는 법칙입니다. 예를 들어 클래스 C의 메서드 f는 아래와 같은 객체의 메서드만 호출해야 합니다.

> 클래스 C
> f가 생성한 객체
> f 인수로 넘어온 객체
> C 인스턴스 변수에 저장된 객체

결국 디미터 법칙은 앞서 말씀드렸던 캡슐화와 깊은 관련이 있습니다.

> **캡슐화란?**
> 객체의 속성(data fields)과 행위(methods)를 하나로 묶고, 실제 구현 내용 일부를 외부에 감추어 은닉하는 것.

캡슐화의 정의를 좀 더 이해하기 쉽게 말하자면, **데이터를 처리하는 방식이 외부에 드러나는 게 아니라 객체 스스로 처리하도록 하게 하는 것**입니다. 그럼 이처럼 자체적으로 데이터를 처리하도록 캡슐화한 객체에서 데이터에 접근하려면 어떻게 해야 할까요?

타입스크립트에는 `getter`와 `setter` 구문을 지원합니다. 객체에서 속성을 찾는 것보다 `getter`와 `setter` 를 사용하는 것을 권장합니다. 이유는 다음과 같습니다.

> 1. 객체 속성을 얻는 것 이상으로 무언가를 더 하고 싶을 때, 코드 안에서 관련된 모든 접근자를 찾고 변경하지 않아도 됩니다. <br/>
> 2. set을 사용할 때 검증 로직을 추가하는 것이 간단합니다. <br/>
> 3. 내부의 API를 캡슐화할 수 있습니다. <br/>
> 4. 값을 조회하고 설정할 때 로그를 기록하고 에러를 처리하는 것이 쉽습니다. <br/>
> 5. 서버에서 객체 속성을 불러올 때 지연 로딩할 수 있습니다.

## 10. 클래스

앞서 살폈던 함수처럼, 좋은 클래스를 판별하는 가장 중요한 척도는 "크기"입니다. 클래스는 가능한 작게 만드는 것이 좋습니다. 함수는 물리적인 행의 수로 크기를 측정했습니다. 클래스는 이와 달리 "맡은 책임"을 기준으로 크기를 측정한다는 점이 다릅니다. 책임이란 말이 조금 어려울 수 있는데요. 아래 예시를 보면 이해에 도움이 될 거에요.

![](https://velog.velcdn.com/images/perfumellim/post/143ac911-5b70-4089-9996-5833f9c0b28c/image.png)

이 `StockPortfolioManager`라는 클래스는 너무 많은 책임을 감당하고 있습니다. 이 클래스가 하는 일을 여러 클래스로 분산시켜주는 것이 좋습니다. 아래 이미지처럼요.

![](https://velog.velcdn.com/images/perfumellim/post/e8718c64-b3b1-4eaa-8941-562edaa927cb/image.png)
이미지 출처: [Mihai Sandu's Medium](https://levelup.gitconnected.com/the-single-responsibility-principle-made-simple-4e1597a44d7d)

자신이 만든 클래스가 적절한 책임을 지고 있는지 확인하는 가장 직관적인 방법은 클래스의 이름을 생각해보는 것입니다. 클래스의 이름은 해당 클래스가 맡은 책임을 설명할 수 있어야 하는데요. 클래스의 이름이 모호하다면 이 클래스가 맡은 책임이 너무 많다는 뜻입니다. 간결한 이름이 떠오르지 않는 것 역시 마찬가지 입니다.

### 단일 책임 원칙(SRP)

책임은 즉, 클래스나 모듈을 변경할 이유를 뜻하는데요. 단일 책임 원칙은 클래스를 변경할 이유가 하나여야 한다는 원칙입니다. 객체 지향 설계에서 특히나 중요한 개념입니다. 책임을 파악하려고 애쓰다 보면 코드를 추상화하기도 쉬워집니다. 앞서 봤던 `StockPortfolioManager` 처럼요.

커다란 하나의 클래스보다 작은 클래스 여럿으로 이뤄진 시스템이 바람직합니다. 작은 클래스는 각자 맡은 책임이 하나며, 다른 작은 클래스와 협력해 시스템에 필요한 동작을 수행합니다. 큰 서랍 하나보다는 용도별로 작은 서랍에 나눠놓는 게 필요한 물건을 찾기 더 좋은 것처럼요.

![](https://velog.velcdn.com/images/perfumellim/post/ec021a43-a715-4b76-9e16-a9665c2a3b90/image.png)
이미지 출처: [Allrecipes](https://www.allrecipes.com/article/the-allrecipes-kitchen-organization-challenge-day-1-junk-drawer-makeover/)

![](https://velog.velcdn.com/images/perfumellim/post/c723a8d8-6dbc-42cc-87b9-d4e05419f32f/image.png)
이미지 출처: [spruce crafts](https://www.thesprucecrafts.com/best-craft-organizers-5087877)

### 응집도

응집도란 **한 모듈 내부의 처리 요소들이 서로 관련되어 있는 정도**를 말합니다. 즉, 모듈이 독립적인 기능을 수행하는지 또는 하나의 기능을 중심으로 책임이 잘 뭉쳐있는지를 나타냅니다. 좋은 소프트웨어 설계는 높은 응집도와 낮은 결합도를 가집니다. <br/>

'함수를 작게, 매개변수 목록을 짧게' 라는 전략을 따르다 보면 몇몇 메서드만 사용하는 인기없는(?) 인스턴스 변수가 많아집니다. 이는 곧 이 클래스의 응집력이 낮아졌다는 것을 뜻합니다. 이럴 때는 클래스를 쪼개는 것이 좋습니다. 변수와 메서드를 적절히 분리해서 작은 클래스 여럿으로 쪼개다 보면 프로그램에 점점 더 체계가 잡히고 구조가 투명해집니다.

### 결합도

좋은 소프트웨어 설계는 높은 응집도와 낮은 결합도를 가진다고 했습니다. 그럼 결합도가 뭘까요? **서로 다른 모듈들이 상호 의존하는 정도 또는 연관된 관계**를 의미합니다. 결합도가 높은 클래스는 다른 클래스와 연관된 정도가 높습니다. 그래서 해당 클래스를 변경하면 연관된 클래스도 변경해야 하고, 다른 코드에서 클래스를 재사용하기도 어렵습니다. 그래서 결합도가 낮은 클래스는 새로운 기능을 추가하거나 기존 기능을 변경할 때 건드릴 코드가 적습니다.

이처럼 결합도를 줄이면 자연히 또 다른 클래스 설계 원칙인 **의존성 역전 원칙(DIP)**를 따르게 됩니다.

의존성 역전 원칙은 크게 두 가지 사항을 요구합니다.

> 1. 상위 레벨의 모듈은 하위 레벨의 모듈에 의존하지 않아야 합니다. 두 모듈은 모두 추상화에 의존해야합니다. <br/>
> 2. 추상화는 세부사항에 의존하지 않아야 합니다. 세부사항은 추상화에 의존해야 합니다. <br/>

## 참고한 글

[디미터 법칙(Law of Demeter)과 묻지 말고 시켜라(Tell, Don’t Ask)](https://prohannah.tistory.com/204) <br/>
[캡슐화란 무엇인가? 어떤 이점이 있는가?](https://bperhaps.tistory.com/32#comment13490914) <br/>
[결합도와 응집도는 무엇일까?](https://madplay.github.io/post/coupling-and-cohesion-in-software-engineering)
