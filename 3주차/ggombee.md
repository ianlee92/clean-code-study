# 6장

변수를 private하게 정의하는 이유는 남들이 변수에 의존하지 않게 만들고 싶어서다..

어째서 수많은 개발자가 조회/설정함수를 public해 비공개 변수를 외부에 노출하는 것일까..?

### 자료 추상화

변수 사이에 함수라는 계층을 넣는다고 구현이 저절로 감춰지지 않으므로 추상화가 필요함.

추상 인터페이스를 제공해 시용자가 구현을 모른 채 자료의 핵심을 조작할 수 있어야 진정한 의미의 클래스.

자료를 세세하게 공개하기보다는 추상적인 개념으로 표현하는 편이 좋음.

### 자료/객체 비대칭

객체는 추상화 뒤로 자료를 숨긴 채 자료를 다루는 함수만 공개

자료 구조는 자료를 그대로 공개하며 별다른 함수는 제공하지 않음

앞서도 말했듯이, 두 방식은 사실상 반대다! 그래서 객체와 자료 구조는 근본적으로 양분된다.

> (자료 구조를 사용하는) 절차적인 코드는 기존 자료 구조를 변경하지 않으면서 새 함수를 추가하기 쉽다. 반면, 객체 지향 코드는 기존 함수를 변경하지 않으면서 새 클래스를 추가하기 쉽다.

반대쪽도 참이다.

> 절차적인 코드는 새로운 자료 구조를 추가하기 어렵다. 그러려면 모든 함수를 고쳐야 한다. 객체 지향 코드는 새로운 함수를 추가하기 어렵다. 그러려면 모든 클래스를 고쳐야 한다.

다시 말해, **객체 지향 코드에서 어려운 변경은 절차적인 코드에서 쉬우며, 절차적인 코드에서 어려운 변경은 객체 지향 코드에서 쉽다!**

복잡한 시스템을 짜다 보면 새로운 함수가 필요할 경우거나, 새로운 자료 타입이 필요한 경우가 생긴다. 이때 상황에 맞게 **클래스 & 객체 지향 기법**을 사용하거나, **절차적인 코드와 자료 구조**를 적절하게 사용하는 것이 좋다.

분별 있는 프로그래머는 모든 것이 객체라는 생각이 **미신**임을 잘 안다. 때로는 단순한 자료 구조와 절차적인 코드가 가장 적합한 상황도 있다.

### 디미터 법칙

휴리스틱heuristic(경험에 기반하여 문제를 해결하거나 학습하거나 발견해 내는 방법)으로, 모듈은 자신이 조작하는 객체의 속사정을 몰라야 한다는 법칙

`"클래스 C의 메서드 f는 다음과 같은 객체의 메서드만 호출해야 한다”`

`=`

**`낯선 사람은 경계하고 친구랑만 놀라는 의미`**

**기차 충돌**

```jsx
final String outputDir = ctxt.getOptions().getScratchDir().getAbsolutePath();
```

피하는 편이 좋다.

```jsx
Options opts = ctxt.getOptions();
File scratchDir = opts.getScratchDir();
final String outputDir = scratchDir.getAbsolutePath();
```

객체라면 내부 구조를 숨겨야 하므로…디미터 법칙을 위반한다.

하지만 자료구조는 내부 구조를 노출하므로 문제되지 않는다.

**잡종 구조**

절반은 객체, 절반은 자료 구조인 잡종 구조가 등장…;

잡종 구조는 중요한 기능을 수행하는 함수도 있고, 공개 변수나 공개 get/set 함수도 있음.

이런 구조는 새로운 함수는 물론이고 새로운 자료 구조도 추가하기 어렵다.

양쪽 세상에서 단점만 모아놓은 구조다. 그러므로 되도록 이런 구조는 피하도록 하자.

**프로그래머가 함수나 타입을 보호할지 공개할지 확신하지 못해 (더 나쁘게는 무지해) 어중간하게 내놓은 설계에 불과하다.**

**구조체 감추기**

점, 슬래시, 파일 확장자, File 객체를 부주의하게 마구 뒤섞으면 안 됨.

듈은 자신이 몰라야 하는 여러 객체를 탐색할 필요가 없다. 따라서 디미터 법칙을 위반하지 않음.

### 자료 전달 객체

**활성 레코드는 자료 구조로 취급한다.**
 비즈니스 규칙을 담으면서 내부 자료를 숨기는 객체는 따로 생성한다. (여기서 내부 자료는 활성 레코드의 인스턴스일 가능성이 높다.)

---

### 결론

객체는 동작을 공개하고 자료를 숨긴다. 그래서 기존 동작을 변경하지 않으면서 새 객체 타입을 추가하기는 쉬운 반면, 기존 객체에 새 동작을 추가하기는 어렵다.
자료 구조는 별다른 동작 없이 자료를 노출한다. 그래서 기존 자료 구조에 새 동작을 추가하기는 쉬우나, 기존 함수에 새 자료 구조를 추가하기는 어렵다.
(어떤) 시스템을 구현할 때, 새로운 자료 타입을 추가하는 유연성이 필요하면 객체가 더 적합하다. 다른 경우로 새로운 동작을 추가하는 유연성이 필요하면 자료 구조와 절차적인 코드가 더 적합하다. 우수한 소프트웨어 개발자는 편견 없이 이 사실을 이해해 직면한 문제에 최적인 해결책을 선택한다.

솔직히 이번 장은 클래스를 잘 사용해 본 적도 없고, 어려운 용어도 많이 나와서 가장 읽기 어려웠다. 자바스크립트에서도 ES6부터 클래스가 추가된지 몇년 되지 않았고, 웬만하면 오브젝트와 함수로 처리해서 클래스를 그렇게 다뤄보지는 않았던 것 같다...

다만 추상화 추상화를 말하며 추상 인터페이스를 제공해 사용자가 구현을 모른 채 자료의 핵심을 조작할 수 있어야 진정한 의미의 클래스라는 문장에 엘리의 드림코딩 자바스크립트 강좌에서 들었던 이야기가 생각났다.

**커피 자판기를 클래스**라고 가정하면, **커피의 개수**와 **동전을 넣는 행위**, **커피를 만드는 행위**는 클래스의 프로퍼티다. 그런데, 만약 **사용자가 커피의 개수를 -1로 설정한다면 어떻게 될까? 또 다른 외부인이 커피의 개수를 맘대로 바꿔버린다면?** 그렇기 때문에 getter와 setter를 사용하며, private 하게 만드는 것이라고 말한다. 사용자는 -1로 설정했지만 내부 setter함수로 0을 만들어주는 것이다. 조회함수와 설정함수를 감춰야 한다는 표현에서 갑자기 이 내용이 생각났다.

# 10장

### 클래스 체계

**static public --> static private --> private 인스턴스 --> (public은 필요한 경우가 거의 없다)**

추상화 단계가 순차적

**캡슐화**

비공개 상태를 유지할 온갖 방법을 강구하고, 캡슐화를 풀어주는 결정은 언제나 최후의 수단

### 클래스는 작아야 한다.

맡은 책임을 측정한다.

**개념은 빈행으로 분리**

### ES5의 함수보다 ES2015/ES6의 클래스를 사용하세요

기존 ES5의 클래스에서 이해하기 쉬운 상속, 구성 및 메소드 정의를 하는 건 매우 어렵습니다. 매번 그런것은 아니지만 상속이 필요한 경우라면 클래스를 사용하는 것이 좋습니다. 하지만 당신이 크고 더 복잡한 객체가 필요한 경우가 아니라면 클래스보다 작은 함수를 사용하세요.

**안좋은 예:**

```jsx
const Animal = function (age) {
  if (!(this instanceof Animal)) {
    throw new Error('Instantiate Animal with `new`');
  }

  this.age = age;
};

Animal.prototype.move = function () {};

const Mammal = function (age, furColor) {
  if (!(this instanceof Mammal)) {
    throw new Error('Instantiate Mammal with `new`');
  }

  Animal.call(this, age);
  this.furColor = furColor;
};

Mammal.prototype = Object.create(Animal.prototype);
Mammal.prototype.constructor = Mammal;
Mammal.prototype.liveBirth = function liveBirth() {};

const Human = function (age, furColor, languageSpoken) {
  if (!(this instanceof Human)) {
    throw new Error('Instantiate Human with `new`');
  }

  Mammal.call(this, age, furColor);
  this.languageSpoken = languageSpoken;
};

Human.prototype = Object.create(Mammal.prototype);
Human.prototype.constructor = Human;
Human.prototype.speak = function speak() {};
```

**좋은 예:**

```jsx
class Animal {
  constructor(age) {
    this.age = age;
  }

  move() {
    /* ... */
  }
}

class Mammal extends Animal {
  constructor(age, furColor) {
    super(age);
    this.furColor = furColor;
  }

  liveBirth() {
    /* ... */
  }
}

class Human extends Mammal {
  constructor(age, furColor, languageSpoken) {
    super(age, furColor);
    this.languageSpoken = languageSpoken;
  }

  speak() {
    /* ... */
  }
}
```

클래스 이름은 해당 클래스 책임을 기술해야된다. 작명은 클래스 크기를 줄이는 첫번째 관문임.

간결한 이름이 떠오르지 않는다면 `클래스 책임이 너무 많아서`

클래스 설명은 "if", "and", "or", "but"을 사용하지 않고 25 단어 내외로 가능해야된다. 한글의 경우 만약, 그리고, ~하며, 하지만 이 들어가면 안됨.

**단일 책임 원칙**

클래스나 모듈을 변경할 이유가 단 하나뿐이어야 한다는 원칙이다.

책임, 즉 변경할 이유를 파악하려고 애쓰다 보면 코드를 추상화 하기도 쉬워짐.

SRP는 객체지향설계에서 더욱 중요한 개념이고, 지키기 수월한 개념인데, `개발자가 가장 무시하는 규칙` 중 하나이다.

대부분의 프로그래머들이 **돌아가는 소프트웨어** 에 초점을 맞춤.

**깨끗하고 체계적인 소프트웨어** 라는 다음 관심사로 전환 필요.

**큰 클래스 몇개가 아니라 작은 클래스 여럿으로 이뤄진 시스템이 더 바람직하다.작은 클래스는 각자 맡은 책임이 하나며, 변경할 이유가 하나며, 다른 작은 클래스와 협력해시스템에 필요한 동작을 수행한다.**

**응집도**

메서드가 변수를 더 많이 사용할 수록 메서드와 클래스는 응집도가 더 높다.

응집도가 높다는 말은 클래스에 속한 메서드와 변수가 서로 의존하며 논리적인 단위로 묶인다는 의미기 때문.

### 변경하기 쉬운 클래스

클래스 일부에서만 사용되는 비공개 메서드는 코드 개선의 잠재적인 여지를 시사

잘 짜여진 시스템은 `추가와 수정에 있어서 건드릴 코드가 최소`이다.

결함도가 낮다는 말은 각 시스템 요소가 다른 요소로부터 그리고 변경으로부터 잘 격리되어있다는 뜻
