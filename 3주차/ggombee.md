# 6장

변수를 private하게 정의하는 이유는 남들이 변수에 의존하지 않게 만들고 싶어서다..

어째서 수많은 개발자가 조회/설정함수를 public해 비공개 변수를 외부에 노출하는 것일까..?

### 자료 추상화

변수 사이에 함수라는 계층을 넣는다고 구현이 저절로 감춰지지 않으므로 추상화가 필요함.

추상 인터페이스를 제공해 시용자가 구현을 모른 채 자료의 핵심을 조작할 수 있어야 진정한 의미의 클래스.

자료를 세세하게 공개하기보다는 추상적인 개념으로 표현하는 편이 좋음.

### 자료/객체 비대칭

객체는 추상화 뒤로 자료를 숨긴 채 자료를 다루는 함수만 공개

자료 구조는 자료를 그대로 공개하며 별다른 함수는 제공하지 않음

앞서도 말했듯이, 두 방식은 사실상 반대다! 그래서 객체와 자료 구조는 근본적으로 양분된다.

> (자료 구조를 사용하는) 절차적인 코드는 기존 자료 구조를 변경하지 않으면서 새 함수를 추가하기 쉽다. 반면, 객체 지향 코드는 기존 함수를 변경하지 않으면서 새 클래스를 추가하기 쉽다.

반대쪽도 참이다.

> 절차적인 코드는 새로운 자료 구조를 추가하기 어렵다. 그러려면 모든 함수를 고쳐야 한다. 객체 지향 코드는 새로운 함수를 추가하기 어렵다. 그러려면 모든 클래스를 고쳐야 한다.

다시 말해, **객체 지향 코드에서 어려운 변경은 절차적인 코드에서 쉬우며, 절차적인 코드에서 어려운 변경은 객체 지향 코드에서 쉽다!**

복잡한 시스템을 짜다 보면 새로운 함수가 필요할 경우거나, 새로운 자료 타입이 필요한 경우가 생긴다. 이때 상황에 맞게 **클래스 & 객체 지향 기법**을 사용하거나, **절차적인 코드와 자료 구조**를 적절하게 사용하는 것이 좋다.

분별 있는 프로그래머는 모든 것이 객체라는 생각이 **미신**임을 잘 안다. 때로는 단순한 자료 구조와 절차적인 코드가 가장 적합한 상황도 있다.

### 디미터 법칙

휴리스틱heuristic(경험에 기반하여 문제를 해결하거나 학습하거나 발견해 내는 방법)으로, 모듈은 자신이 조작하는 객체의 속사정을 몰라야 한다는 법칙

`"클래스 C의 메서드 f는 다음과 같은 객체의 메서드만 호출해야 한다”`

`=`

**`낯선 사람은 경계하고 친구랑만 놀라는 의미`**

**기차 충돌**

```jsx
final String outputDir = ctxt.getOptions().getScratchDir().getAbsolutePath();
```

피하는 편이 좋다.

```jsx
Options opts = ctxt.getOptions();
File scratchDir = opts.getScratchDir();
final String outputDir = scratchDir.getAbsolutePath();
```

객체라면 내부 구조를 숨겨야 하므로…디미터 법칙을 위반한다.

하지만 자료구조는 내부 구조를 노출하므로 문제되지 않는다.

**잡종 구조**

절반은 객체, 절반은 자료 구조인 잡종 구조가 등장…;

잡종 구조는 중요한 기능을 수행하는 함수도 있고, 공개 변수나 공개 get/set 함수도 있음.

이런 구조는 새로운 함수는 물론이고 새로운 자료 구조도 추가하기 어렵다.

양쪽 세상에서 단점만 모아놓은 구조다. 그러므로 되도록 이런 구조는 피하도록 하자.

**프로그래머가 함수나 타입을 보호할지 공개할지 확신하지 못해 (더 나쁘게는 무지해) 어중간하게 내놓은 설계에 불과하다.**

**구조체 감추기**

점, 슬래시, 파일 확장자, File 객체를 부주의하게 마구 뒤섞으면 안 됨.

듈은 자신이 몰라야 하는 여러 객체를 탐색할 필요가 없다. 따라서 디미터 법칙을 위반하지 않음.

### 자료 전달 객체

**활성 레코드는 자료 구조로 취급한다.**
 비즈니스 규칙을 담으면서 내부 자료를 숨기는 객체는 따로 생성한다. (여기서 내부 자료는 활성 레코드의 인스턴스일 가능성이 높다.)

---

### 결론

객체는 동작을 공개하고 자료를 숨긴다. 그래서 기존 동작을 변경하지 않으면서 새 객체 타입을 추가하기는 쉬운 반면, 기존 객체에 새 동작을 추가하기는 어렵다.
자료 구조는 별다른 동작 없이 자료를 노출한다. 그래서 기존 자료 구조에 새 동작을 추가하기는 쉬우나, 기존 함수에 새 자료 구조를 추가하기는 어렵다.
(어떤) 시스템을 구현할 때, 새로운 자료 타입을 추가하는 유연성이 필요하면 객체가 더 적합하다. 다른 경우로 새로운 동작을 추가하는 유연성이 필요하면 자료 구조와 절차적인 코드가 더 적합하다. 우수한 소프트웨어 개발자는 편견 없이 이 사실을 이해해 직면한 문제에 최적인 해결책을 선택한다.

솔직히 이번 장은 클래스를 잘 사용해 본 적도 없고, 어려운 용어도 많이 나와서 가장 읽기 어려웠다. 자바스크립트에서도 ES6부터 클래스가 추가된지 몇년 되지 않았고, 웬만하면 오브젝트와 함수로 처리해서 클래스를 그렇게 다뤄보지는 않았던 것 같다...

다만 추상화 추상화를 말하며 추상 인터페이스를 제공해 사용자가 구현을 모른 채 자료의 핵심을 조작할 수 있어야 진정한 의미의 클래스라는 문장에 엘리의 드림코딩 자바스크립트 강좌에서 들었던 이야기가 생각났다.

**커피 자판기를 클래스**라고 가정하면, **커피의 개수**와 **동전을 넣는 행위**, **커피를 만드는 행위**는 클래스의 프로퍼티다. 그런데, 만약 **사용자가 커피의 개수를 -1로 설정한다면 어떻게 될까? 또 다른 외부인이 커피의 개수를 맘대로 바꿔버린다면?** 그렇기 때문에 getter와 setter를 사용하며, private 하게 만드는 것이라고 말한다. 사용자는 -1로 설정했지만 내부 setter함수로 0을 만들어주는 것이다. 조회함수와 설정함수를 감춰야 한다는 표현에서 갑자기 이 내용이 생각났다.
