## 1장) 깨끗한 코드

책 <클린코드>의 1장에서는 우리에게 ‘클린코드’, 즉 깨끗한 코드가 필요한 이유와 깨끗한 코드의 정의에 대해서 다뤘습니다. 왜 우리에게 깨끗한 코드가 필요할까요? 깨끗한 코드를 쓰면 생산성이 증대되고, 이를 통해 비용이 절감됩니다. 그러니 전문가 수준의 프로그래머가 되고 싶다면 깨끗한 코드를 쓰기 위해 노력해야 합니다. 많은 프로그래머들이 기한을 맞추려면 나쁜 코드를 쓸 수 밖에 없다고 생각합니다. 하지만 모순적이게도 나쁜 코드를 양산할수록 작업 속도가 떨어져서 결코 기한에 맞출 수 없습니다.

그럼 깨끗한 코드를 어떻게 작성할까요? 깨끗한 코드를 작성하기 위해선 먼저 무엇이 '깨끗한 코드'인지 이해해야 합니다. 그래서 비야네 스트롭스트룹, 그래디 부치,데이브 토마스 등 유명한 프로그래머들에게 깨끗한 코드에 대한 의견을 물었습니다.

모두 다른 답변을 했지만 그들이 말하고자 하는 바는 비슷했습니다.

> '한 가지에만 집중해 제대로 하는 코드'
> '유지보수가 쉬운 코드'
> '테스트 케이스를 작성한 코드'
> '중복이나 군더더기가 없는 깔끔한 코드'

그리고 중요한 것은, **읽기 쉬운 코드**라는 점입니다. 프로그래머들은 코드를 짜는 시간보다 읽는 시간이 훨씬 깁니다. 새 코드를 짜면서 끊임 없이 기존 코드를 읽기 때문입니다. 그러므로 급할 수록, 기한이 빠듯할 수록 오히려 읽기 쉬운 코드를 짜기 위해 주의를 기울여야 합니다.

여기에 덧붙여 **보이스카우트 규칙**을 소개하고 싶습니다.

> 캠프장은 처음 왔을 때보다 더 깨끗하게 해놓고 떠나라.

아무리 좋은 코드를 작성했어도 시간이 지나면서 나쁜 코드로 전락하는 경우가 많습니다. 하지만 보이스카우트 규칙처럼 체크아웃할 때보다 좀 더 깨끗한 코드를 체크인하면 코드는 절대 나빠지지 않습니다. 전문 프로그래머라면 이같은 코드의 지속적인 개선을 반드시 신경써야 합니다.

## 2장) 의미있는 이름

1장에서 좋은 코드는 '읽기 쉬운 코드'라는 이야기를 했습니다. 읽기 쉬운 코드를 작성하기 위해선 변수나 함수 그리고 클래스가 **어떤 걸 가리키는지 명확하게 알 수 있는 이름**을 짓는 것이 중요합니다. 좋은 이름을 지으려면 시간이 걸리지만 좋은 이름으로 절약하는 시간이 훨씬 더 많습니다. 예시로 아래 코드를 보겠습니다.

```
public List<int[]> getThem() {
    List<int[]> list1 = new ArrayList<int[]>();
    for(int[] x: theList)
        if(x[0]= 4) list1.add(x)
        return list1

}
```

코드가 복잡하지도 않고 연산자의 수와 상수의 갯수도 적으며 화려한 클래스도 없습니다. 그럼에도 불구하고 읽었을 때 이 코드가 하는 일을 짐작하기가 어렵습니다. 하지만 아래 코드를 한 번 읽어보세요.

```
public List<int[]> getFlaggedCells() {
    List<int[]> flaggedCells = new ArrayList<int[]>();
    for(int[] cell: gameBoard)
        if(cell[STATUS_VALUE] == FLAGGED) flaggedCells.add(cell)
        return flaggedCells;

}
```

각 개념에 이름을 붙여줬을 뿐인데 코드가 하는 바가 확 명확해졌습니다. 이것이 이름의 효과입니다. 그럼 어떻게 하면 좋은 이름을 지을 수 있을까요? 좋은 이름을 짓기 위해서는 몇 가지 규칙이 있습니다.

### 오해의 여지가 없는 이름 짓기

읽는 이가 잘못된 추측을 할 수 있는 단어를 사용하지 않아야 합니다. 예를 들어 여러 계정을 그룹으로 묶었기 때문에 accountList라고 명명했는데, 실제 계정을 담는 컨테이너는 List가 아닌 상황을 가정해봅시다. 프로그래밍에서 List는 특수한 의미를 가진 단어이기 때문에 읽는 사람에게 혼동을 줄 수 있습니다.

### 의미 있게 구분하기

이름 짓기가 귀찮은 나머지, a1, a2, a3.. 이렇게 연속적인 숫자를 덧붙이거나 불용어(의미가 없는 단어)를 추가하는 방식을 선택하는 경우가 있습니다. 이런 이름은 아무런 정보를 제공하지 못하며, 저자의 의도가 전혀 드러나지 않습니다.

특히 **불용어를 추가한 이름**에 대해 좀 더 말해보겠습니다. Product라는 클래스가 있다고 가정해봅시다. 이미 Product라는 이름의 클래스가 있기 때문에, 다른 클래스를 대충 ProductInfo 혹은 ProductData라고 부른다면 어떨까요? 개념을 구분하지 않고 이름만 달리 했기 때문에 사용할 때마다 어떤 게 제가 원하는 클래스인지 확인해봐야 할 것입니다. 또다른 예시를 봅시다.

```
getActiveAccount();
getActiveAccounts();
getActiveAccountInfo();
```

여러분이 이 프로젝트에 참여한 프로그래머라면 어느 함수를 호출해야 할지 어떻게 알 수 있을까요? 아마 세 함수의 코드를 모두 찾아서 읽어봐야 할 것입니다.

### 발음하기 쉬운 이름을 사용하기

말 그대로 쉽게 읽고 말할 수 있는 이름을 사용해야 합니다. 개발자는 커뮤니케이션 할 일이 많습니다. 그때마다 `genymdhms(젠 와이 엠 디 에이취 엠 에스)`라는 이름을 더듬더듬 읽는 것보다는 `Generation Timestamp`라는 편이 보다 지적인 대화가 가능하겠죠.

### 검색하기 쉬운 이름을 사용하기

이름을 의미있게 지으면 함수가 길어집니다. 하지만 그만큼 검색하기가 쉬워집니다. ide에서 5를 검색했을 때 얼마나 많은 결과물이 나올지 상상해보십시오. 하지만 WORK_DAYS_PER_WEEK 같은 이름은 아주 쉽게 찾을 수 있을 겁니다.

### 사람들이 이해할 수 있는 이름을 사용하기

'r'이라는 변수를 보고 이 변수의 이름이 호스트와 프로토콜을 제외한 소문자 URL이라는 사실을 알아차릴 수 있는 사람이 얼마나 있을까요? 심지어는 그 코드를 작성한 본인조차도 나중에 시간이 지나서 다시 보면 r의 의미를 잊어버렸을 확률이 높습니다. 설령 스스로 이 변수에 대해 기억할 자신이 있더라도, 보는 사람이 명료하게 이해할 수 있는 이름을 지어야 합니다.

또한 속어나 비유적 표현처럼 특정 문화를 향유하는 사람만 이해할 수 있는 이름도 지양해야 합니다. 다시 한 번 말씀드리자면 명료함은 좋은 이름의 필수 조건입니다.

### 일관성 있게 이름 짓기

추상적인 개념 하나에 단어 하나를 선택해 이를 일관성 있게 고수하는 것이 좋습니다. 예를 들어 똑같은 메서드를 클래스마다 fetch, retrieve, get으로 제각각 부르면 혼란스럽겠죠. 어느 클래스에서 어느 이름을 썼는지 기억하기 어렵습니다.

하지만 이 '일관성'을 오해하면 안됩니다. 같은 맥락이 아닌데도 일관성을 고려해 잘못된 이름을 정하는 경우가 있습니다. 예를 들어, 그동안 기존 값 두 개를 더하거나 이어서 새로운 값을 만드는 메서드들의 이름에 'add'를 붙였다고 합시다. 그런데 집합에 값 하나를 추가하는 메서드를 '일관성'을 고려한다는 이유로 add라고 불러도 괜찮을까요? 아닙니다. 기존 add 메서드들과는 맥락이 다르기 때문에 insert나 append같은 이름이 적당합니다.

### 적절한 개념을 인용해 이름 짓기

코드를 읽을 사람도 프로그래머라는 사실을 잊지 마세요. 그러므로 전산 용어, 알고리즘 이름, 패턴 이름 등은 얼마든지 사용해도 괜찮습니다. 프로그래머에게 익숙한 기술 개념을 사용하면 읽는 사람이 금방 이해할 수 있습니다.

하지만 적절한 '프로그래머 용어'가 없다면 도메인, 즉 문제 영역에서 이름을 가져오세요. 그러면 이 코드의 보수를 맡게 된 프로그래머가 분야 전문가에게 의미를 물어 파악할 수 있습니다.

훌륭한 프로그래머라면 해법 영역과 문제 영역을 구분할 줄 알아야 합니다. 문제 영역 개념과 관련이 깊은 코드라면 문제 영역에서 이름을 가져오세요.

## 3장) 함수

모든 프로그램의 기본 단위는 함수입니다. 그만큼 중요한 함수를 어떻게 하면 '잘' 만들 수 있을까요? 당연히 좋은 함수를 만드는 것은 쉽지 않은 일입니다. 하지만 좋은 함수를 만드는 방법 자체는 단 한 줄로 요약할 수 있습니다.

> **한 가지만 제대로 하는 작은 함수를 만들어라!**

함수는 작게 만들 수록 좋습니다. 또한 그 작은 함수가 한 가지만 해야 합니다. 그리고 그 한 가지를 **잘** 해야 합니다. 이 규칙들에 대한 자세한 내용은 아래에서 살펴보겠습니다.

### 함수 당 추상화 수준은 하나로

앞서 말씀드린 좋은 함수를 만드는 규칙에서 말하는 '한 가지'란 어느 정도를 말하는 걸까요? 프로그래밍에서는 추상화 수준이 하나인 단계만 수행하면 한 가지 동작으로 간주합니다.

#### 추상화?

추상화란 복잡한 구조, 원리, 설명을 간추리고 핵심만 간추리는 것을 뜻합니다.이 추상화에는 수준이라는 지표가 있습니다. 추상화 수준이란 **해당 코드를 읽으면서 파악할 수 있는 정보의 수준**을 말합니다. 즉, 추상화 수준이 낮아질 수록 보다 상세한 정보를 다룹니다.

_e.g)_

> **높음:** `getHtml()`이라는 함수는 HTML을 가져오는 것만 알 수 있고, 어떤 것이랑 연관되어 있는지 알 수 없기 때문에 추상화 수준이 높다고 할 수 있습니다.
> **보통:** `String pagePathName = PathParser.render(pagepath);`는 PathParser객체의 render 함수를 이용해 pagePathName을 가져올 수 있다는 정보를 유추할 수 있기 때문에 추상화 수준이 보통이라고 할 수 있습니다.<br/>
> **낮음:** `.append("\n")`는 바로 어떤 의미인지 유추 가능하기 때문에 추상화 수준이 낮다고 할 수 있습니다.

한 함수 내에 여러 추상화 수준을 섞으면 특정 표현이 높은 추상화 수준인지 낮은 추상화 수준인지 구분하기 어렵기 때문에 코드를 읽는 사람이 헷갈릴 수 있습니다. 따라서 **한 함수의 모든 문장은 하나의 추상화 수준이어야 합니다.**

또한 '내려가기 규칙'이라는 것이 있습니다.

**내려가기 규칙이란?**

코드는 위에서 아래로 이야기처럼 읽혀야 좋습니다. 한 함수 다음에는 추상화 수준이 한 단계 더 낮은 함수가 와야합니다. 즉, 위에서 아래로 코드를 읽으면 함수 추상화 수준이 한 번에 한 단계씩 낮아집니다.

### 함수의 인수는 적을 수록 좋다

좋은 함수는 극강의 미니멀리즘을 추구함으로써 만들어집니다. 인수의 갯수도 당연히 적을수록 좋습니다. 가장 인상적인 개수는 0개입니다. 왜냐하면 인수가 늘어날 수록 테스트 해야하는 경우의 수가 매우 많아지고, 코드를 제대로 파악하기가 어려워지기 때문입니다.

인수가 여러 개 필요하다면 객체 리터럴을 사용하는 것도 고려해볼 수 있습니다. 여기에 구조분해 구문을 사용하면 여러 장점을 갖게 됩니다.

> 1. 어떤 사람이 함수 시그니쳐(매개변수의 타입, 반환값의 타입 등)를 볼 때, 어떤 속성이 사용되는지 즉시 알 수 있습니다.
> 2. 명명된 매개변수처럼 보이게 할 때 사용할 수 있습니다.
> 3. 또한 구조 분해는 함수로 전달된 매개변수 객체의 특정한 원시 값을 복제하며 이것은 사이드 이펙트를 방지하는데 도움을 줍니다. 유의사항: 매개변수 객체로부터 구조 분해된 객체와 배열은 복제되지 않습니다.
> 4. 타입스크립트는 사용하지 않은 속성에 대해서 경고를 주며, 구조 분해를 사용하면 경고를 받지 않을 수 있습니다.

**냄새나는 코드:**

```
function createMenu(title: string, body: string, buttonText: string, cancellable: boolean) {
  // ...
}

createMenu('Foo', 'Bar', 'Baz', true);
```

**개선된 코드:**

```
function createMenu(options: { title: string, body: string, buttonText: string, cancellable: boolean }) {
  // ...
}

createMenu({
  title: 'Foo',
  body: 'Bar',
  buttonText: 'Baz',
  cancellable: true
});
```

위의 예시에 타입 앨리어스를 추가해 가독성을 더 높일 수도 있습니다.

```
type MenuOptions = { title: string, body: string, buttonText: string, cancellable: boolean };

function createMenu(options: MenuOptions) {
  // ...
}

createMenu({
  title: 'Foo',
  body: 'Bar',
  buttonText: 'Baz',
  cancellable: true
});
```

### 중복된 코드 제거하기

코드가 중복되지 않도록 하세요. 중복된 코드는 어떤 로직을 변경할 때 한 곳 이상을 변경해야 하기 때문에 좋지 않습니다. 함수를 작성할 때 몇 가지 차이점이 있다고 생각해서 거의 비슷한 코드를 중복 작성하는 경우가 많습니다. 하지만 이는 결국 같은 역할을 하는 두 개 이상의 함수를 만드는 셈입니다.

이런 중복된 코드를 제거하기 위해 앞서 말했던 추상화 과정이 필요합니다. 같은 역할을 하는 코드끼리 묶고, 이들을 따로 빼서 함수 하나에 묶음으로써 코드를 보다 효율적이고 간단하게 만들 수 있습니다. 하지만 올바르지 않은 추상화는 중복된 코드보다 나쁘므로 주의하세요. 코드의 추상화 수준과 목적을 잘 파악하고, 올바르게 할 수 있으면 하라는 뜻입니다.

위와 관련된 내용을 예시로 확인해보겠습니다.

**냄새나는 코드:**

```
function showDeveloperList(developers: Developer[]) {
  developers.forEach((developer) => {
    const expectedSalary = developer.calculateExpectedSalary();
    const experience = developer.getExperience();
    const githubLink = developer.getGithubLink();

    const data = {
      expectedSalary,
      experience,
      githubLink
    };

    render(data);
  });
}

function showManagerList(managers: Manager[]) {
  managers.forEach((manager) => {
    const expectedSalary = manager.calculateExpectedSalary();
    const experience = manager.getExperience();
    const portfolio = manager.getMBAProjects();

    const data = {
      expectedSalary,
      experience,
      portfolio
    };

    render(data);
  });
}
```

**개선된 코드:**

```
class Developer {
  // ...
  getExtraDetails() {
    return {
      githubLink: this.githubLink,
    }
  }
}

class Manager {
  // ...
  getExtraDetails() {
    return {
      portfolio: this.portfolio,
    }
  }
}

function showEmployeeList(employee: Developer | Manager) {
  employee.forEach((employee) => {
    const expectedSalary = employee.calculateExpectedSalary();
    const experience = employee.getExperience();
    const extra = employee.getExtraDetails();

    const data = {
      expectedSalary,
      experience,
      extra,
    };

    render(data);
  });
}
```

## 참조

책 <클린코드> <br/>
[클린코드 타입스크립트](https://738.github.io/clean-code-typescript/)<br/>
[Spline Tech Blog](https://dev-splin.github.io/clean%20code/CleanCode-Chapter3/)<br/>
[클린코드 강의 2. 추상화](https://ablue-1.tistory.com/81)<br/>
