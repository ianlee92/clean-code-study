### 📅 2023년 3월 8일

# 📚 11장 시스템

## 깨끗한 시스템을 만들기 위해 필요한 4가지

1. 테스트 주도 시스템 아키텍쳐를 구축할 것

- 코드수준에서 아키텍처 관심사를 적절히 분리할 수 있다면, 진정한 테스트 주도 아키텍처 구축이 가능해진다.

2. 의사 결정을 최적화 할 것

- 모듈을 나누고 관심사를 분리하면 지엽적인 관리와 결정이 가능해진다.
  그래서, 가장 적합한 사람에게 책임을 맡기는 것이 아주 중요하다.

3. 명백한 가치가 있을 때 표준을 현명하게 사용할 것

- 표준을 적절히 잘 사용하면, 아이디어와 컴포넌트를 재사용하기 쉽고 적절한 경험을 가진 사람을 구하기 쉬우며 좋은 아이디어를 캡슐화하기 쉽고 컴포넌트를 엮기 쉽게 만들어 줍니다!

4. 시스템은 도메인 특화 언어를 사용할 것

## 결론

=> 추상화 단계에서 의도는 명확하게 표현하고, 각 구현에서의 관심사를 적절하게 분리하게 되면 깨끗한 시스템을 설계할 수 있다.

# 📚 12장 창발성

## 창발적 설계로 깔끔한 코드를 구현하자

- 켄트 벡이 제시한 단순한 설계 규칙 네 가지가 소프트웨어 설계 품질을 크게 높혀준다고 한다.

1. 모든 테스트를 실행한다.

- 테스트가 불가능한 시스템은 검증도 불가능하다. 논란의 여지는 있지만, 검증이 불가능한 시스템은 절대 출시하면 안 된다. 테스트가 가능한 시스템을 만들려고 애쓰면 설계 품질이 더불어 높아진다. 크기가 작고 목적 하나만 수행하는 클래스가 나온다.
- 테스트 케이스를 모두 작성했다면 이제 코드와 클래스를 정리해도 괜찮다. 구체적으로는 코드를 점진적으로 리팩터링 해나간다. 리팩터링 단계에서는 소프트웨어 설계 품질을 높이는 기법이라면 무엇이든 적용해도 괜찮다. 응집도를 높이고, 결합도를 낮추고, 관심사를 분리하고, 시스템 관심사를 모듈로 나누고, 함수와 클래스 크기를 줄이고, 더 나은 이름을 선택하는 등 다양한 기법을 동원한다.

2. 중복을 없앤다.

- 우수한 설계에서 중복은 커다란 적이다. 중복은 추가 작업, 추가 위험, 불필요한 복잡도를 뜻하기 때문이다. 똑같은 코드는 당연히 중복이다. 비슷한 코드는 더 비슷하게 고쳐주면 리팩터링이 쉬워진다. 구현 중복도 중복의 한 형태다.

3. 프로그래머 의도를 표현한다.

- 자신이 이해하는 코드를 짜기는 쉽다. 하지만 나중에 코드를 유지보수할 사람이 그만큼 문제를 깊이 이해할 가능성은 희박하다.
- 좋은 이름을 선택한다
  - 이름과 기능이 완전 따로 노는 클래스나 함수를 사용해선 안된다.
- 함수와 클래스 크기를 가능한 한 줄인다
  - 작은 클래스와 작은 함수는 이름 짓기도 쉽고, 구현하기도 쉬우며 이해하기도 쉽다.
- 표준 명칭을 사용한다
  - 클래스가 COMMAND 와 같은 표준 패턴을 사용해 구현된다면 클래스 이름에 패턴 이름을 넣어준다.
- 단위 테스트 케이스를 꼼꼼히 작성한다.
  - 테스트 케이스는 소위 '예제로 보여주는 문서'다. 다시 말해, 잘 만든 테스트 케이스를 읽어보면 클래스 기능이 한눈에 들어온다.

4. 클래스와 메서드 수를 최소로 줄인다.

- 목표는 함수와 클래스 크기를 작게 유지하면서 동시에 시스템 크기도 작게 유지하는 데 있다. 하지만 이 규칙은 간단한 설계 규칙 네 개 중 우선순위가 가장 낮다. 다시 말해, 클래스와 함수 수를 줄이는 작업도 중요하지만, 테스트 케이스를 만들고 중복을 제거하고 의도를 표현하는 작업이 더 중요하다는 뜻이다.

# 📚 13장 동시성

## 동시성이 필요한 이유?

- 동시성은 결합Coupling 을 없애는 전략이다. 즉, 무엇what과 언제when를 분리하는 전략이다.

## 동시성 방어 원칙

1. 단일 책임 원칙Single Responsibility Principle, SRP

- 동시성은 복잡성 하나만으로도 따로 분리할 이유가 충분하다. 즉, 동시성 관련 코드는 다른 코드와 분리해야 한다. 동시성 코드에는 독자적인 난관이 있다. 다른 코드에서 겪는 난관과 다르며 훨씬 어렵다. 잘못 구현한 동시성 코드는 별의별 방식으로 실패한다.

2. 따름 정리Corollary: 자료 범위를 제한하라

- 객체 하나를 공유한 후 동일 필드를 수정하면 스레드간 간섭으로 예상치 못한 결과가 나타난다. 이런 문제를 해결하는 방안으로 공유 객체를 사용하는 코드 내 임계영역critical section을 synchronized 키워드로 보호하라고 권장한다. 자료를 캡슐화encapsulation하라. 공유 자료를 최대한 줄여라.

3. 따름 정리: 자료 사본을 사용하라

- 공유 자료를 줄이려면 처음부터 공유하지 않는 방법이 제일 좋다. 각 스레드가 객체를 복사해 사용한 후 해당 사본에서 결과를 가져오는 방식도 있다. 사본 생성 비용과 가비지 컬렉션에 드는 비용과 동기화로 인한 복잡성과 내부 락 비용을 비교해 적절히 선택하라.

4. 따름 정리: 스레드는 가능한 독립적으로 구현하라

- 자신만의 세상에 존재하는 스레드로 구현하라. 다른 스레드와 자료를 공유하지 않고 모든 정보를 비공유 출처에서 가져와 로컬 변수로 저장한다. 독자적인 스레드로, 가능하면 다른 프로세서에서 돌려도 괜찮도록 자료를 독립적인 단위로 분할하라.
