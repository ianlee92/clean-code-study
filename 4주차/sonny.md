# 7장. 오류 처리

## 깨끗한 코드와 오류 처리의 연관성 (p.130)

```md
상당수 코드 기반은 전적으로 오류 처리 코드에 좌우된다.

여기저기 흩어진 오류 처리 코드 때문에 실제 코드가 하는 일을 파악하기가 거의 불가능하다는 의미다.
```

## 오류 코드보다 예외를 사용하라 (p.130)

```md
호출자 코드가 복잡해진다. 함수를 호출한 즉시 오류를 확인해야 하기 때문이다.

오류가 발생하면 예외를 던지는 편이 낫다. 그러면 호출자 코드가 더 깔끔해진다. 논리가 오류 처리 코드와 뒤섞이지 않으니까.
```

try - catch를 사용하는 이유에 대해 생각해볼 수 있어서 좋았다.

## Try-Catch-Finally 문부터 작성하라 (p.132)

```md
예외가 발생할 코드를 짤 때는 try-catch-finally 문으로 시작하는 편이 낫다.

그러면 try 블록에서 무슨 일이 생기는지 호출자가 기대하는 상태를 정의하기 쉬워진다.
```

## 예외에 의미를 제공하라 (p.135)

```md
오류 메시지에 정보를 담아 예외와 함께 던진다.
```

## 호출자를 고려해 예외 클래스를 정의하라 (p.137)

```md
외부 API를 감싸면 외부 라이브러리와 프로그램 사이에 의존성이 크게 줄어든다.

또한 감싸기 클래스에서 외부 API를 호출하는 대신 테스트 코드를 넣어주는 방법으로 프로그램을 테스트하기도 쉬워진다.
```

## 특수 사례 패턴 (p.138)

```md
클래스를 만들거나 객체를 조작해 특수 사례를 처리하는 방식

클래스나 객체가 예외적인 상황을 캡슐화해서 처리하므로 클라이언트 코드가 예외적인 상황을 처리할 필요가 없어진다.
```

## null을 반환하지 마라 (p.139)

```md
null 확인이 너무 많아 문제다. 메서드에서 null을 반환하고픈 유혹이 든다면 그 대신 예외를 던지거나 특수 사례 객체를 반환한다.

사용하려는 외부 API가 null을 반환한다면 감싸기 메서드를 구현해 예외를 던지거나 특수 사례 객체를 반환하는 방식을 고려한다.
```
요 부분 되게 좋다!

# 8장. 경계

## 외부 코드 사용하기 (p. 146)

```md
경계 인터페이스를 안으로 숨긴다. 따라서 인터페이스가 변하더라도 나머지 프로그램에는 영향을 미치지 않는다.

프로그램에 필요한 인터페이스만 제공한다.
 - 코드는 이해하기 쉽지만 오용하기는 어렵다.
 - 설계 규칙과 비즈니스 규칙을 따르도록 강제할 수 있다.
```

## 학습 테스트 (p. 147)

```md
우리쪽 코드를 작성해 외부 코드를 호출하는 대신 먼저 간단한 테스트 케이스를 작성해 외부 코드를 익히는 테스트

학습 테스트는 API를 사용하려는 목적에 초점을 맞춘다.
```

이 방식 너무 유용한 것 같다!

## 학습 테스트는 공짜 이상이다. (p.149)

```md
필요한 지식만 확보하는 손쉬운 방법이다. 학습테스트는 이해도를 높여주는 정확한 실험이다.

패키지 새 버전이 나온다면 학습 테스트를 돌려 차이가 있는지 확인한다.

학습 테스트는 패키지가 예상대로 도는지 검증한다. 일단 통합된 이후라고 하더라도 패키지가 우리 코드와 호환되리라는 보장은 없다.

패키지 작성자에게 코드를 변경할 필요가 생길지도 모른다.

새 버전이 우리 코드와 호환되지 않으면 학습 테스트가 이 사실을 곧바로 밝혀낸다.
```

이 부분 너무 좋다! 마이그레이션 시, 활용을 해보면 좋을 것 같다.

## 아직 존재하지 않는 코드를 사용하기 (p.151)

```md
우리가 바라는 인터페이스를 구현하면 우리가 인터페이스를 전적으로 통제한다는 장점이 생긴다.
또한 코드 가독성도 높아지고 코드 의도도 분명해진다.

ADAPTER 패턴으로 API 사용을 캡슐화해 API가 바뀔 때 수정할 코드를 한곳으로 모았다.
```

책에서 나온 ADAPTER 패턴을 찾아보았는데 다음과 같았다. Axios의 interceptor로 데이터를 변환하는 느낌..? 🤔

- 한 클래스의 인터페이스를 클라이언트에서 사용하고자하는 다른 인터페이스로 변환한다. 어댑터를 이용하면 인터페이스 호환성 문제 때문에 같이 쓸 수 없는 클래스들을 연결해서 쓸 수 있다.

## 깨끗한 경계 (p.152)

```md
경계에 위치하는 코드는 깔끔히 분리한다. 또한 기대치를 정의하는 테스트 케이스도 작성한다.

통제가 불가능한 외부 패키지에 의존하는 대신 통제가 가능한 우리 코드에 의존하는 편이 훨씬 좋다.

외부 패키지를 호출하는 코드를 가능한 줄여 경계를 관리하자.

새로운 클래스로 경계를 감싸거나 아니면 ADAPTOR 패턴을 사용해 우리가 원하는 인터페이스를 패키지가 제공하는 인터페이스로 변환하자.
```

# 9장. 단위 테스트

## TDD 법칙 세 가지 (p.155)

1. 실패하는 단위 테스트를 작성할 때까지 실제 코드를 작성하지 않는다.
2. 컴파일은 실패하지 않으면서 실행이 실패하는 정도로만 단위 테스트를 작성한다.
3. 현재 실패하는 테스트를 통과할 정도로만 실제 코드를 작성한다.

## 깨끗한 테스트 코드 유지하기 (p.156)

```md
테스트 코드가 복잡할수록 실제 코드를 짜는 시간보다 테스트 케이스를 추가하는 시간이 더 걸리기 쉽상이다.

테스트 슈트가 없으면 케발자는 자신이 수정한 코드가 제대로 도는지 확인할 방법이 없다.

테스트는 실제 코드 못지 않게 중요하다. 테스트 코드는 이류 시민이 아니다. 테스트 코드는 사고와 설계와 주의가 필요하다.
실제 코드 못지 않게 깨끗하게 짜야 한다.
```

## 테스트는 유연성, 유지보수성, 재사용성을 제공한다. (p.157)

```md
테스트 케이스가 없으면 실제 코드를 유연하게 만드는 버팀목도 사라진다.

코드에 유연성, 유지보수성, 재사용성을 제공하는 버팀목이 바로 단위 테스트다.
=> 테스트 케이스가 있으면 변경이 두렵지 않기 때문!

테스트 케이스가 없다면 모든 변경이 잠정적인 버그다.

실제 코드를 점검하는 자동화된 단위 테스트 슈트는 설계와 아키텍처를 최대한 깨끗하게 보존하는 열쇠다. 테스트 케이스가 있으면 변경이 쉬워지기 때문이다.
```

## 깨끗한 테스트 코드 (p. 158)

```md
어쩌면 가독성은 실제 코드보다 테스트 코드에 더더욱 중요하다.

명료성, 단순성, 풍부한 표현력이 필요하다.

테스트 코드는 최소의 표현으로 많은 것을 나타내야 한다.
```

## BUILD-OPERATE-CHECK 패턴 (p.161)

**BUILD**

- 테스트 자료를 만든다.

**OPERATE**

- 테스트 자료를 조작한다.

**CHECK**

- 조작한 결과가 올바른지 확인한다.

=> 그 결과

```md
테스트 코드는 본론에 돌입해 진짜 필요한 자료 유형과 함수만 사용한다.

코드가 수행하는 기능을 재빨리 이해할 수 있다.
```

## 테스트 당 assert 하나 (p.164)

```md
assert 문이 단 하나인 함수는 결론이 하나라서 코드를 이해하기 쉽고 빠르다.

테스트를 분리하면 중복되는 코드가 많아진다.
=> TEMPLATE METHOD 패턴 사용하여 중복 제거
=> given/when 부분을 부모 클래스에 두고 then 부분을 자식 클래스에 두기ㅌㅈ
```

## 깨끗한 테스트가 따르는 다섯 가지 규칙, F.I.R.S.T (p.167 ~ p.168)

**Fast (빠르게)**

- 테스트는 빨리 돌아야 한다.
- 테스트가 느리면 자주 돌릴 엄두를 못낸다.
- 자주 돌리지 않으면 초반에 문제를 찾아내 고치지 못한다.
- 코드를 마음껏 정리하지도 못한다.
=> 결국 코드 품질이 망가지기 시작한다.

**Independent (독립적으로)**

- 각 테스트는 서로 의존하면 안 된다.
- 각 테스트는 독립적으로, 어떤 순서로 실행해도 괜찮아야 한다.

**Repeatable (반복가능하게)**

- 어떤 환경에서도 반복 가능해야 한다.
- 노트북 환경에서도, 어느 환경에서도 실행할 수 있어야 한다.
- 테스트가 돌아가지 않는 환경이 하나라도 있다면 테스트가 실패한 이유를 둘러댈 변명이 생긴다.

**Self-Validating (자가검증하는)**

- 테스트는 boolean 값으로 결과를 내야 한다. (성공 or 실패)

**Timely (적시에)**

- 테스트는 적시에 작성해야 한다.
- 단위 테스트는 테스트하려는 실제 코드를 구현하기 직전에 구현한다.