### ðŸ“… 2023ë…„ 2ì›” 22ì¼

# ðŸ“š 7ìž¥ ì˜¤ë¥˜ ì²˜ë¦¬

- í´ë¦° ì½”ë“œëŠ” ì½ê¸°ë„ ì¢‹ì•„ì•¼ í•˜ì§€ë§Œ ì•ˆì •ì„±ë„ ë†’ì•„ì•¼ í•œë‹¤.

- ì˜ˆì™¸ì²˜ë¦¬ë¥¼ ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§ê³¼ ë¶„ë¦¬í•´ ë…ìžì ì¸ ì‚¬ì•ˆìœ¼ë¡œ ê³ ë ¤í•˜ë©´ íŠ¼íŠ¼í•˜ê³  ê¹¨ë—í•œ ì½”ë“œë¥¼ ìž‘ì„±í•  ìˆ˜ ìžˆë‹¤.

## nullì„ ì „ë‹¬í•˜ì§€ ë§ˆë¼

**Bad:**

```java
public class MetricsCalculator
{
 public double xProjection(Point p1, Point p2) {
 return (p2.x â€“ p1.x) * 1.5;
 }
 â€¦
}
```

**Good:**

```java
public class MetricsCalculator
{
 public double xProjection(Point p1, Point p2) {
  if (p1 == null || p2 == null) {
    throw InvalidArgumentException(
    "Invalid argument for MetricsCalculator.xProjection");
  }
  return (p2.x â€“ p1.x) * 1.5;
 }
}
```

# ðŸ“š 8ìž¥ ê²½ê³„

- ì‹œìŠ¤í…œì— ë“¤ì–´ê°€ëŠ” ëª¨ë“  ì†Œí”„íŠ¸ì›¨ì–´ë¥¼ ì§ì ‘ ê°œë°œí•˜ëŠ” ê²½ìš°ëŠ” ë“œë¬¼ë‹¤. íŒ¨í‚¤ì§€ë¥¼ ì‚¬ê±°ë‚˜, ì˜¤í”ˆ ì†ŒìŠ¤ë¥¼ ì´ìš©í•˜ê±°ë‚˜, ì‚¬ë‚´ ë‹¤ë¥¸ íŒ€ì´ ì œê³µí•˜ëŠ” ì™¸ë¶€ ì½”ë“œë¥¼ ìš°ë¦¬ ì½”ë“œì— ê¹”ë”í•˜ê²Œ í†µí•©í•´ì•¼ë§Œ í•œë‹¤.

## ê²½ê³„ ì‚´í”¼ê³  ìµížˆê¸°

- ì‚¬ìš©ë²•ì´ ë¶„ëª…ì¹˜ ì•Šì€ íƒ€ì‚¬ ë¼ì´ë¸ŒëŸ¬ë¦¬ë¥¼ ê°€ì ¸ì™”ë‹¤ê³  ê°€ì •í•˜ìž. í•˜ë£¨ë‚˜ ì´í‹€ê°„ ë¬¸ì„œë¥¼ ì½ìœ¼ë©° ì‚¬ìš©ë²•ì„ ê²°ì •í•˜ê³ , ìš°ë¦¬ ìª½ ì½”ë“œë¥¼ ìž‘ì„±í•´ ë¼ì´ë¸ŒëŸ¬ë¦¬ê°€ ì˜ˆìƒëŒ€ë¡œ ë™ìž‘í•˜ëŠ”ì§€ í™•ì¸í•œë‹¤. ë•Œë¡œëŠ” ë²„ê·¸ê°€ ìž‘ì„±í•œ ì½”ë“œì—ì„œ ë°œìƒí•œ ê²ƒì¸ì§€, ë¼ì´ë¸ŒëŸ¬ë¦¬ì—ì„œ ë°œìƒí•œ ê²ƒì¸ì§€ ì°¾ì•„ë‚´ëŠë¼ ì˜¤ëžœ ì‹œê°„ ê³¨ë¨¸ë¦¬ë¥¼ ì•“ê¸°ë„ í•œë‹¤.

- ì™¸ë¶€ ì½”ë“œë¥¼ ìµížˆê¸´ ì–´ë µë‹¤. ì™¸ë¶€ ì½”ë“œë¥¼ í†µí•©í•˜ê¸°ë„ ì–´ë µë‹¤. ë‘ ê°€ì§€ë¥¼ ë™ì‹œì— í•˜ëŠ” ê±´ ë°°ë¡œ ì–´ë µë‹¤. ìš°ë¦¬ ìª½ ì½”ë“œë¥¼ ìž‘ì„±í•´ ì™¸ë¶€ ì½”ë“œë¥¼ í˜¸ì¶œí•˜ëŠ” ëŒ€ì‹  ë¨¼ì € ê°„ë‹¨í•œ í…ŒìŠ¤íŠ¸ ì¼€ì´ìŠ¤ë¥¼ ìž‘ì„±í•´ ì™¸ë¶€ ì½”ë“œë¥¼ ìµížˆëŠ” ë°©ì‹ìœ¼ë¡œ ë‹¤ë¥´ê²Œ ì ‘ê·¼í•˜ë©´ ì–´ë–¨ê¹Œ? ì§ ë‰´ì»¤í¬(Jim Newkirk)ëŠ” ì´ë¥¼ í•™ìŠµ í…ŒìŠ¤íŠ¸ë¼ ë¶€ë¥¸ë‹¤.

- í•™ìŠµ í…ŒìŠ¤íŠ¸ëŠ” í”„ë¡œê·¸ëž¨ì—ì„œ ì‚¬ìš©í•˜ë ¤ëŠ” ë°©ì‹ëŒ€ë¡œ ì™¸ë¶€ APIë¥¼ í˜¸ì¶œí•œë‹¤. í†µì œëœ í™˜ê²½ì—ì„œ APIë¥¼ ì œëŒ€ë¡œ ì´í•´í•˜ëŠ”ì§€ í™•ì¸í•˜ëŠ” ì…ˆì´ë‹¤. í•™ìŠµ í…ŒìŠ¤íŠ¸ëŠ” APIë¥¼ ì‚¬ìš©í•˜ë ¤ëŠ” ëª©ì ì— ì´ˆì ì„ ë§žì¶˜ë‹¤.

# ðŸ“š 9ìž¥ ë‹¨ìœ„ í…ŒìŠ¤íŠ¸

## í…ŒìŠ¤íŠ¸ í•˜ë‚˜ì— í•˜ë‚˜ì˜ ê°œë…ì„ ìž‘ì„±í•˜ì„¸ìš”

- í…ŒìŠ¤íŠ¸ëŠ” ë‹¨ì¼ ì±…ìž„ ì›ì¹™ì„ ë”°ë¼ì•¼ í•©ë‹ˆë‹¤. ë‹¨ìœ„ í…ŒìŠ¤íŠ¸ í•˜ë‚˜ë‹¹ í•˜ë‚˜ì˜ assert êµ¬ë¬¸ì„ ìž‘ì„±í•˜ì„¸ìš”.

**Bad:**

```jsx
import { assert } from "chai";

describe("AwesomeDate", () => {
  it("handles date boundaries", () => {
    let date: AwesomeDate;

    date = new AwesomeDate("1/1/2015");
    assert.equal("1/31/2015", date.addDays(30));

    date = new AwesomeDate("2/1/2016");
    assert.equal("2/29/2016", date.addDays(28));

    date = new AwesomeDate("2/1/2015");
    assert.equal("3/1/2015", date.addDays(28));
  });
});
```

**Good:**

```jsx
import { assert } from "chai";

describe("AwesomeDate", () => {
  it("handles 30-day months", () => {
    const date = new AwesomeDate("1/1/2015");
    assert.equal("1/31/2015", date.addDays(30));
  });

  it("handles leap year", () => {
    const date = new AwesomeDate("2/1/2016");
    assert.equal("2/29/2016", date.addDays(28));
  });

  it("handles non-leap year", () => {
    const date = new AwesomeDate("2/1/2015");
    assert.equal("3/1/2015", date.addDays(28));
  });
});
```

## í…ŒìŠ¤íŠ¸ì˜ ì´ë¦„ì€ í…ŒìŠ¤íŠ¸ì˜ ì˜ë„ê°€ ë“œëŸ¬ë‚˜ì•¼ í•©ë‹ˆë‹¤

- í…ŒìŠ¤íŠ¸ê°€ ì‹¤íŒ¨í•  ë•Œ, í…ŒìŠ¤íŠ¸ì˜ ì´ë¦„ì€ ì–´ë–¤ ê²ƒì´ ìž˜ëª»ë˜ì—ˆëŠ”ì§€ ë³¼ ìˆ˜ ìžˆëŠ” ì²« ë²ˆì§¸ í‘œì‹œìž…ë‹ˆë‹¤.

**Bad:**

```jsx
describe("Calendar", () => {
  it("2/29/2020", () => {
    // ...
  });

  it("throws", () => {
    // ...
  });
});
```

**Good:**

```jsx
describe("Calendar", () => {
  it("should handle leap year", () => {
    // ...
  });

  it("should throw when format is invalid", () => {
    // ...
  });
});
```
