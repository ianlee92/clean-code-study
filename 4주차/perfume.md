## 7장 오류 처리

오류 처리는 프로그램에 반드시 필요한 요소 중 하나입니다. 그만큼 중요하지만, 오류 처리 코드로 인해 프로그램 논리를 이해하기 어려워진다면 깨끗한 코드라고 할 수 없습니다.

그렇다면 어떻게 해야 오류를 잘 처리하면서 깨끗한 코드를 쓸 수 있을까요? 정답은 **비즈니스 논리와 오류 처리를 잘 분리**하는 겁니다. 이렇게 하면 독립적인 추론이 가능해지고 코드 유지보수성도 크게 높아집니다. 그럼 잘 분리하기 위해서는 어떻게 해야 할까요?

- Try, Catch , Finally 문부터 작성하세요 <br/>
- 호출자를 고려해서 예외 클래스를 정의하고, 예외를 던질 때 전후 사항을 덧붙이세요. <br/>
- null을 반환하지 마세요. <br/>

7장 오류 처리 부분을 읽으면서 React의 Suspense 생각이 났습니다. suspense가 목표로 하는 바가 로딩 상태와 에러 상태는 외부에 위임하고(ErrorBoundary) 성공한 경우에만 집중해서 코드를 작성하는 거라고 알고 있거든요.

### 7장에서 이해가 잘 안 간 부분:

137p

> 실제로 외부 API를 사용할 때는 감싸기 기법이 최선이다. 외부 API를 감싸면 외부 라이브러리와 프로그램 사이에서 의존성이 크게 줄어든다. (중략) 마지막 장점으로 감싸기 기법을 사용하면 특정 업체가 API를 설계한 방식에 발목 잡히지 않는다.

### 7장에서 인상 깊던 부분:

- (클린코드 책 말고 클린코드 타입스크립트에서) 에러를 던질 때 raw string 말고 반드시 Error 타입을 사용하라는 부분이 도움이 됐어요. Error 객체가 발생한 위치를 자동으로 추적해주는 걸 처음 알았어요.

- 단위 테스트를 구현하는 부분에서, 강제로 예외를 일으키는 테스트 케이스를 작성한 후, try문의 트랜잭션 범위를 좁혀나가면서 TDD를 하는 부분이 인상 깊었습니다.

## 8장 경계

8장에서는 별달리 어렵거나 특별하게 정리할만한 부분은 없었고 학습 테스트 부분만 인상적이었습니다.

## 9장 단위 테스트

단위 테스트는 너무나도 중요합니다. 코드에 유연성, 유지보수성, 재사용성을 제공하는 버팀목이 되기 때문입니다. 테스트 케이스가 없으면 코드를 선뜻 변경하기가 쉽지 않습니다. 버그가 숨어들 수 있으니까요. 그래서 단위 테스트는 설계와 아키텍처를 최대한 깨끗하게 보존할 수 있게 해주는 열쇠입니다.

**TDD의 세 가지 법칙**

> 1. 실패하는 단위 테스트를 작성하기 전에는 실제 코드를 작성하지 마세요.<br/>
> 2. 컴파일은 실패하지 않으면서 실행이 실패하는 정도로만 단위 테스트를 작성하세요. <br/>
> 3. 실패하는 단위 테스트를 통과할 정도로만 실제 코드를 작성하세요.

### F.I.R.S.T

**F(Fast) 빠르게:** 테스트는 빨리 돌아야 합니다. 돌리는 시간이 짧아야 자주 돌려볼 수 있습니다. <br/>

**I(Independent) 독립적으로:** 각 테스트는 서로 독립적이어야 합니다. 한 테스트가 다음 테스트가 실행될 환경을 준비해서는 안됩니다. 어떤 순서로 실행해도 괜찮아야 합니다. <br/>

**R(Repeatable) 반복가능하게:** 테스트는 어떤 환경에서도 가능해야 합니다. 테스트가 돌아가지 않는 환경이 있다면 테스트의 실패의 변명으로 삼기 쉽습니다. <br/>

**S(Self-Validating) 자가검증하는: **테스트는 무조건 성공 혹은 실패 두 가지 결과로만 나와야 합니다. 그렇지 않으면 테스트 결과를 추가로 판단하는 과정이 필요하게 됩니다. <br/>

**T(Timely) 적시에:** 테스트 코드를 먼저 작성한 다음 실제 코드를 작성해야 합니다. <br/>

👀) 예전에 TDD 관련 라이브 세션에서 테스트코드를 프로덕션 코드보다 먼저 작성해야 한다고 들었던 기억이 나요. 프로덕션을 먼저 짜면 답정너처럼 원하는 결과가 나오도록 테스트를 짜게 되서 TDD를 하는 의미가 퇴색된다고.

### 테스트 하나 당 하나의 개념을 작성하세요

테스트 코드 역시 클래스를 작성할 때처럼 단일책임원칙을 따라 작성해야 합니다.

**나쁜 예시**

```
import { assert } from 'chai';

describe('AwesomeDate', () => {
  it('handles date boundaries', () => {
    let date: AwesomeDate;

    date = new AwesomeDate('1/1/2015');
    assert.equal('1/31/2015', date.addDays(30));

    date = new AwesomeDate('2/1/2016');
    assert.equal('2/29/2016', date.addDays(28));

    date = new AwesomeDate('2/1/2015');
    assert.equal('3/1/2015', date.addDays(28));
  });
});
```

**좋은 예시**

```
import { assert } from 'chai';

describe('AwesomeDate', () => {
  it('handles 30-day months', () => {
    const date = new AwesomeDate('1/1/2015');
    assert.equal('1/31/2015', date.addDays(30));
  });

  it('handles leap year', () => {
    const date = new AwesomeDate('2/1/2016');
    assert.equal('2/29/2016', date.addDays(28));
  });

  it('handles non-leap year', () => {
    const date = new AwesomeDate('2/1/2015');
    assert.equal('3/1/2015', date.addDays(28));
  });
});
```
